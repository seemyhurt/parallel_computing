<!DOCTYPE html>
<html>

<head>
    <title>Параллельные вычисления. Прикладные аспекты</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta name="description" content="Прикладные аспекты параллельных вычислений">
    <meta name="keywords" content="OpenMP, Параллельные высчиления, Атомарность">
    <link rel="stylesheet" type="text/css" href="style/page_style.css">

    <style>
        pre code {
            background-color: #051600;
            border-radius: 10px;
            padding: 10px;
            display: block;
            color: #d6cccc;
            font-family: 'Courier New', Courier, monospace;
            font-size: 1.2em;
            line-height: 1.5;
            margin: 20px auto;
            overflow-x: auto;
            width: 80%;
            white-space: pre-line;
            text-align: center;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            border: 2px solid #929292;
        }

        table caption {
            font-size: 1.5em;
            margin: 10px 0;
        }

        thead {
            background-color: #f2f2f2;
        }

        thead th {
            padding: 10px;
            text-align: left;
            border: 2px solid #b4b4b4;
        }

        tbody td {
            padding: 10px;
            border: 2px solid #919191;
            background-color: #e2e9d2;
        }

        tfoot td {
            padding: 10px;
            background-color: #f2f2f2;
            font-style: italic;
            text-align: center;
        }
    </style>
</head>

<body>
    <div id="container">
        <header>
            <img src="assets/logo.png" alt="Логотип">
            <h1>Параллельные вычисления<br>Прикладные аспекты</h1>
        </header>

        <nav>
            <h2>Меню навигации</h2>
            <a href="index.html">Главная страница</a>
            <a href="modern.html">Прикладные аспекты</a>
            <a href="sources.html">Использованные источники</a>
            <a href="script.html">Суперкомпьютеры</a>
        </nav>

        <aside>
            <h2>Содержание</h2>
            <ol>
                <li><a href="#aspects">Прикладные аспекты параллельных вычислений</a>
                    <ul>
                        <li><a href="#approaches">Основные подходы к распараллеливанию</a></li>
                        <li><a href="#atomic">Атомарность операций</a></li>
                        <li><a href="#parallelization">Автоматическое распараллеливание</a></li>
                    </ul>
                </li>
                <li><a href="#openmp">Технология OpenMP</a>
                    <ul>
                        <li><a href="#overview">Краткая характеристика</a></li>
                        <li><a href="#compilers">Поддержка компиляторами</a></li>
                        <li><a href="#features">Особенности</a></li>
                    </ul>
                </li>
            </ol>
        </aside>

        <main>
            <section id="aspects">
                <h2>Прикладные аспекты параллельных вычислений</h2>

                <article id="approaches">
                    <h3>Основные подходы к распараллеливанию</h3>

                    <p>На практике сложилось достаточное большое количество шаблонов
                        параллельного программирования. Однако все эти шаблоны в своей основе
                        используют всего два базовых подхода к распараллеливанию:</p>
                    <ul>
                        <li>Распараллеливание по данным:
                            <ul>
                                <li>Определяется массив данных, который последовательно обрабатывается программой</li>
                                <li>Массив разбивается на блоки, которые могут быть обработы независимо друг от друга
                                </li>
                                <li>Обработка блоков данных запускается в нескольких потоках</li>
                            </ul>
                        </li>
                        <li>Распараллеливание по инструкциям:
                            <ul>
                                <li>
                                    Определяются последовательно выполняемые функции,
                                    процесс которых не влияет друг на друга
                                </li>
                                <li>
                                    Дополнительно происходит процесс атомизации остальных функций -
                                    ограничиваются глобальные
                                    переменные и результаты работы функций
                                </li>
                                <li>Данные функции запускаются в отдельных потоках</li>
                            </ul>
                        </li>
                    </ul>
                </article>

                <article id="atomic">
                    <h3>Атомарность операций</h3>

                    <p>Основная проблема параллельного программирования - конфликты при одновременном
                        доступе к общей памяти несколькими потоками. Примитивы синхронизации часто
                        используются для устранения этих конфликтов. Возникает вопрос:
                        существуют ли атомарные операции, выполнение которых не требует синхронизации? </p>

                    <p>Атомарными являются большинство ассемблерных инструкций, выполняемых процессором "одним махом".
                        Однако команды языка С обычно транслируются в несколько ассемблерных инструкций.
                        Например, команда инкремента "w++" транслируется в три инструкции, что делает небезопасным
                        выполнение инкремента:</p>

                    <pre><code> movl w, %ecx
                            addl $1, %ecx
                            movl %ecx, w </code></pre>

                    <p>Операции присваивания могут быть атомарными, если их размер не превышает разрядность процессора.
                        Например, присваивание переменной типа int на 32-разрядном процессоре будет атомарным,
                        а на 16-разрядном — нет.
                        Присваивание константы 64-разрядной переменной обычно также не атомарно:</p>

                    <pre><code> movabsq $9999999999999, %rsi 
                            movq %rsi, s </code></pre>

                    <p>В общем, атомарность операций присваивания и чтения переменных не гарантируется для всех типов
                        данных и зависит от аппаратной платформы. Для потокобезопасности такие операции нужно защищать
                        мьютексами или критическими секциями.</p>
                </article>

                <article id="parallelization">
                    <h3>Автоматическое распараллеливание</h2>
                        <p>Параллельное программирование – достаточно сложный ручной
                            процесс, поэтому кажется очевидной необходимость его автоматизировать
                            с помощью компилятора. Такие попытки делаются, однако эффективность
                            автораспараллеливания пока что оставляет желать лучшего, т.к. хорошие
                            показатели параллельного ускорения достигаются лишь для ограниченного
                            набора операций. Основная характеристика автоматического
                            распределения представлена в таблице ниже.</p>

                        <table>
                            <caption>Автоматическое распараллеливание</caption>
                            <thead>
                                <tr>
                                    <th>Категория</th>
                                    <th>Описание</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td rowspan="2">Виды автоматического распараллеливания</td>
                                    <td><strong>Полностью автоматический:</strong> участие программиста не требуется,
                                        все действия выполняет компилятор</td>
                                </tr>
                                <tr>
                                    <td><strong>Полуавтоматический:</strong> программист даёт
                                        указания компилятору в виде специальных ключей,
                                        которые позволяют регулировать некоторые аспекты распараллеливания</td>
                                </tr>
                                <tr>
                                    <td rowspan="5">Слабые стороны автоматического распараллеливания</td>
                                    <td>Возможно ошибочное изменение логики программы</td>
                                </tr>
                                <tr>
                                    <td>Возможно понижение скорости вместо повышения</td>
                                </tr>
                                <tr>
                                    <td>Отсутствие гибкости ручного распараллеливания</td>
                                </tr>
                                <tr>
                                    <td>Эффективно распараллеливаются только циклы</td>
                                </tr>
                                <tr>
                                    <td>Невозможность распараллелить программы со сложным алгоритмом работы</td>
                                </tr>
                                <tr>
                                    <td rowspan="3">Примеры компиляторов</td>
                                    <td>
                                        <img src="assets/gcc.png" alt="GCC"
                                            style="float: left; width: 70px; height: 70px; margin-right: 8px;">
                                        Компилятор GNU Compiler Collection:
                                        <kbd>gcc -O2 -floop-parallelize-all
                                            -ftree-parallelize-loops=K -fdump-tree-parloops-details src.c</kbd>
                                        <br>Подробнее:
                                        <cite><a href="https://gcc.gnu.org/wiki/AutoParInGCC">AutoParInGCC</a></cite>
                                    </td>
                                </tr>
                                <tr>
                                    <td>
                                        <img src="assets/intel.png" alt="GCC"
                                            style="float: left; width: 70px; height: 70px; margin-right: 8px;">
                                        Компилятор фирмы Intel:
                                        <kbd>icc -c -parallel -par-report file.cc</kbd>
                                    </td>
                                </tr>
                                <tr>
                                    <td>
                                        <img src="assets/oracle.png" alt="GCC"
                                            style="float: left; width: 70px; height: 70px; margin-right: 8px;">
                                        Компилятор фирмы Oracle:
                                        <kbd>solarisstudio -cc -O3 -xautopar -xloopinfo src.c</kbd>
                                    </td>
                                </tr>
                            </tbody>
                            <tfoot>
                                <tr>
                                    <td colspan="2">
                                        Компиляторы помогают автоматизировать процесс распараллеливания
                                        программ, но они имеют свои ограничения и недостатки.
                                    </td>
                                </tr>
                            </tfoot>
                        </table>
                </article>
            </section>

            <section id="openmp">
                <h2>Технология <abbr title="Open Multi-Processing">OpenMP</abbr></h2>

                <article id="overview">
                    <h3>Краткая характеристика технологии</h3>

                    <picture>
                        <source srcset="assets/OpenMP_hlogo.png" media="(orientation: portrait)">
                        <img src="assets/OpenMP_logo.png" alt="" />
                    </picture>

                    <p>Первая версия стандарта OpenMP появилась в 1997 году при поддержке крупнейших
                        <abbr title="Information Technology">IT</abbr>-компаний мира
                        (Intel, IBM, AMD, HP, Nvidia и др.). Целью нового стандарта было предложить
                        <em>кроссплатформенный</em> инструмент для распараллеливания, который был бы более
                        высокоуровневый, чем <abbr title="Application Programming Interface">API</abbr> управления
                        потоками, предлагаемые операционной системой. На данный момент OpenMP стандартизована для трёх
                        языков программирования: С, С++ и Фортран.
                    </p>
                </article>

                <article id="compilers">
                    <h3>Поддержка компиляторами</h3>
                    <p>Абсолютное большинство существующих современных компиляторов С/С++ поддерживают OpenMP версии 2.0
                        (например, как gcc, так и Visual Studio). Однако лишь немногие компиляторы поддерживают более
                        новую версию OpenMP 4.0, поэтому далее при изложении материала будет в качестве "общего
                        знаменателя" использоваться технология OpenMP 2.0.</p>
                    <table>
                        <caption>Поддержка OpenMP в компиляторах</caption>
                        <thead>
                            <tr>
                                <th>Название компилятора</th>
                                <th>Ключ компилятору для включения OpenMP</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Gcc</td>
                                <td><kbd>-fopenmp</kbd></td>
                            </tr>
                            <tr>
                                <td>icc (Intel C/C++ compiler)</td>
                                <td><kbd>-openmp</kbd></td>
                            </tr>
                            <tr>
                                <td>Sun C/C++ compiler</td>
                                <td><kbd>-xopenmp</kbd></td>
                            </tr>
                            <tr>
                                <td>Visual Studio C/C++ compiler</td>
                                <td><kbd>/openmp</kbd></td>
                            </tr>
                            <tr>
                                <td>PGI (Nvidia C/C++ compiler)</td>
                                <td><kbd>-mp</kbd></td>
                            </tr>
                        </tbody>
                    </table>
                    <p>Помимо препроцессорных директив, OpenMP определяет набор библиотечных функций, для вызова которых
                        в исходном коде потребуется подключить заголовочный файл OpenMP:</p>
                    <pre><code>#include &lt;omp.h&gt;</code></pre>
                </article>

                <article id="features">
                    <h3>Отличительные особенности</h3>
                    
                    <p>
                        Среди прочих технологий распараллеливания OpenMP выделяется следующими важными характеристиками:
                    </p>
                    <ul type="square">
                        <li><dfn>Инкрементное распараллеливание</dfn> - OpenMP позволяет распараллеливать существующую
                            последовательную программу в виде небольших
                            итераций-правок, на каждой из которых будет достигаться всё больший коэффициент
                            распараллеленности программы.</li>
                        <li><dfn>Обратная совместимость</dfn> - распараллеленная программа будет корректно
                            скомпилирована в однопоточном режиме даже на
                            старом компиляторе, который не поддерживает OpenMP, если не используются библиотечные
                            функции OpenMP</li>
                        <li><dfn>Высокий уровень абстракций</dfn> - одна директива OpenMP приводит к значительной
                            трансформации исходного кода, добавляя логику
                            управления потоками, что упрощает процесс распараллеливания</li>
                        <li><dfn>Низкий коэффициент трансформации</dfn> - OpenMP требует значительно меньше изменений
                            в исходном коде по сравнению с другими
                            технологиями распараллеливания благодаря высокому уровню абстракции</li>
                        <li><dfn>Поддержка крупнейшими IT-гигантами</dfn> - OpenMP поддерживается крупнейшими
                            IT-компаниями, что обеспечивает высокое качество и
                            актуальность стандарта в современных компиляторах</li>
                        <li><dfn>Автоматическое масштабирование</dfn> - OpenMP автоматически управляет количеством
                            потоков в зависимости от количества доступных
                            процессоров, но также позволяет настроить это вручную</li>
                    </ul>
                </article>

                <article id="webinar">
                    <h3>Изучение OpenMP</h3>

                    <p>В данном вебинаре представлены рекомендацию по использованию OpenMP для асинхронной разгрузки
                        процессора. Кроме того, показано, как OpenMP поддерживает сочетание с моделями
                        программирования на <em><abbr title="Graphics Processing Unit">GPU</abbr></em>.</p>

                    <video controls src="assets/videoplayback.mp4"></video>
                </article>
            </section>
        </main>
    </div>

    <div id="clear"></div>
    <footer>
        <section id="contact-info">
            <p>Связь с разработчиком:</p>
            <address>
                <a href="mailto:artemsobakin2001@mail.ru">Электронная почта</a><br>
                <a href="tel:+79999999999">Телефон</a>
            </address>
        </section>
        <section id="copyright">
            <p>© 2025, Параллельные вычисления. Все права защищены.</p>
        </section>
    </footer>

</body>
</html>